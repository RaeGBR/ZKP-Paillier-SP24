@import "./math.djinni"

ECPoint = interface +c {
  static create(x: Integer, y: Integer): ECPoint;

  getX(): Integer;
  getY(): Integer;
  setX(num: Integer);
  setY(num: Integer);
  eq(b: ECPoint): bool;
  inv(curve: ECCurve): ECPoint;
  add(curve: ECCurve, b: ECPoint): ECPoint;
  sub(curve: ECCurve, b: ECPoint): ECPoint;
  mul(curve: ECCurve, b: Integer): ECPoint;
}

ECCurve = interface +c {
  static create(p: Integer, a: Integer, b: Integer, n: Integer, g: ECPoint): ECCurve;
  static SECP256K1(): ECCurve;
  static getPublicElement(publicKey: binary): ECPoint;
  static getPrivateElement(privateKey: binary): Integer;

  getP(): Integer;
  getA(): Integer;
  getB(): Integer;
  getN(): Integer;
  getG(): ECPoint;

  computeGenerator(seed: binary): ECPoint;

  inv(a: ECPoint): ECPoint;
  add(a: ECPoint, b: ECPoint): ECPoint;
  sub(a: ECPoint, b: ECPoint): ECPoint;
  mul(a: Integer, b: ECPoint): ECPoint;
  multiply(a: Integer, b: ECPoint): ECPoint;
  verify(p: ECPoint): bool;
  encodePoint(p: ECPoint, compressed: bool): binary;
  decodePoint(encoded: binary): ECPoint;
}

KeyPair = interface +c {
  static create(curve: ECCurve): KeyPair;
  static createWithSeed(curve: ECCurve, seed: binary): KeyPair;
  static createWithPrivateKey(curve: ECCurve, privateKey: binary): KeyPair;

  getCurve(): ECCurve;
  getPrivateKey(): binary;
  getPublicKey(): binary;
  getPublicElement(): ECPoint;
  getPrivateElement(): Integer;
  eq(b: KeyPair): bool;
}
